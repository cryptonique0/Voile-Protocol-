# Voile Protocol - Exit Note Script
# This script is executed when an LP consumes an exit note to advance liquidity
#
# INPUTS (via note_inputs):
#   [0-3]:   unstake_amount (4 felts)
#   [4-7]:   unlock_timestamp (4 felts)
#   [8-11]:  user_account_id (4 felts, first 2 felts contain the ID)
#   [12-15]: fee_rate (4 felts)
#   [16-19]: min_advance_amount (4 felts)
#
# STACK OUTPUT:
#   [1] on success, [0] on failure

use.miden::contracts::wallets::basic
use.miden::account
use.miden::note
use.miden::tx

# Helper procedure to validate LP eligibility
# Checks if the consuming account is authorized to act as an LP
proc.validate_lp_eligibility
    # Get consuming account ID
    exec.account::get_id
    # [ACCT_ID]
    
    # TODO: Add reputation/whitelist checking logic here
    # For now, we allow any account to be an LP
    # In production, check against a registry or reputation score
    
    # Validate account has minimum balance for liquidity provision
    # This ensures LPs have sufficient funds
    push.1000000  # Minimum balance requirement (example: 1M base units)
    # [MIN_BAL, ACCT_ID]
    
    # Get account vault asset count (simplified check)
    drop drop drop drop drop
    # []
    
    # Return success
    push.1
    # [1]
end

# Helper procedure to calculate advance amount
# Takes unstake amount and fee rate, returns advance amount
proc.calculate_advance_amount
    # STACK: [unstake_amount (4 felts), fee_rate (4 felts)]
    # We'll work with the first felt only for simplicity
    
    # Get unstake amount (first felt)
    movup.3 movup.3 movup.3
    # [unstake_amount_f0, fee_rate (4 felts)]
    
    # Get fee rate (first felt)
    movup.4 movup.4 movup.4
    # [fee_rate_f0, unstake_amount_f0, ...]
    
    # Calculate fee: (unstake_amount * fee_rate) / 10000 (basis points)
    dup.1 dup.1 mul
    # [amount * rate, fee_rate_f0, unstake_amount_f0, ...]
    
    push.10000 div
    # [fee, fee_rate_f0, unstake_amount_f0, ...]
    
    # Calculate advance: unstake_amount - fee
    movup.2 movup.1 drop
    # [unstake_amount_f0, fee, ...]
    
    dup.1 sub
    # [advance_amount, fee, ...]
    
    # Clean up stack and return advance amount as 4 felts
    swap drop
    # [advance_amount, ...]
    
    # Pad to 4 felts
    push.0 push.0 push.0
    # [0, 0, 0, advance_amount, ...]
    
    movup.3
    # [advance_amount, 0, 0, 0, ...]
end

# Helper procedure to create repayment claim note for LP
proc.create_repayment_claim_note
    # STACK: [lp_account_id (4 felts), repayment_amount (4 felts), unlock_timestamp (4 felts)]
    
    # This creates a note that represents the LP's claim to repayment
    # The note will be consumed when the settlement occurs
    
    # In practice, this would create a note with:
    # - Assets: None (claim-only)
    # - Script: Repayment claim script
    # - Inputs: LP ID, amount, timestamp
    
    # For now, we'll just validate the inputs and return success
    # Actual note creation would use exec.tx::create_note
    
    # Clean up stack
    dropw dropw dropw
    # []
    
    push.1
    # [1]
end

# Main exit note script entry point
begin
    # ================================================
    # STEP 1: Validate LP Eligibility
    # ================================================
    exec.validate_lp_eligibility
    # [is_valid]
    
    # Assert LP is valid
    assert
    # []
    
    # ================================================
    # STEP 2: Load Note Inputs
    # ================================================
    # Load unstake amount
    push.0 exec.note::get_inputs
    # [unstake_amount_f0]
    push.1 exec.note::get_inputs
    # [unstake_amount_f1, unstake_amount_f0]
    push.2 exec.note::get_inputs
    # [unstake_amount_f2, unstake_amount_f1, unstake_amount_f0]
    push.3 exec.note::get_inputs
    # [unstake_amount_f3, unstake_amount_f2, unstake_amount_f1, unstake_amount_f0]
    
    # Load unlock timestamp
    push.4 exec.note::get_inputs
    push.5 exec.note::get_inputs
    push.6 exec.note::get_inputs
    push.7 exec.note::get_inputs
    # [unlock_ts (4 felts), unstake_amount (4 felts)]
    
    # Load user account ID
    push.8 exec.note::get_inputs
    push.9 exec.note::get_inputs
    push.10 exec.note::get_inputs
    push.11 exec.note::get_inputs
    # [user_acct_id (4 felts), unlock_ts (4 felts), unstake_amount (4 felts)]
    
    # Load fee rate
    push.12 exec.note::get_inputs
    push.13 exec.note::get_inputs
    push.14 exec.note::get_inputs
    push.15 exec.note::get_inputs
    # [fee_rate (4 felts), user_acct_id (4 felts), unlock_ts (4 felts), unstake_amount (4 felts)]
    
    # ================================================
    # STEP 3: Calculate Advance Amount
    # ================================================
    # Stack rearrangement to get unstake_amount and fee_rate
    # Current: [fee_rate (4), user_acct_id (4), unlock_ts (4), unstake_amount (4)]
    # Need: [unstake_amount (4), fee_rate (4)]
    
    # Save fee_rate temporarily
    movup.15 movup.15 movup.15 movup.15
    # [unstake_amount (4 felts), user_acct_id (4), unlock_ts (4), fee_rate (4)]
    
    # Get fee_rate back
    movup.11 movup.11 movup.11 movup.11
    # [fee_rate (4), unstake_amount (4), user_acct_id (4), unlock_ts (4)]
    
    # Now extract just unstake_amount and fee_rate
    # Keep others on stack for later
    dup.7 dup.7 dup.7 dup.7
    # [unstake_amount (4), fee_rate (4), unstake_amount (4), user_acct_id (4), unlock_ts (4)]
    
    dup.3 dup.3 dup.3 dup.3
    # [fee_rate (4), unstake_amount (4), fee_rate (4), unstake_amount (4), user_acct_id (4), unlock_ts (4)]
    
    # Calculate advance
    exec.calculate_advance_amount
    # [advance_amount (4 felts), fee_rate (4), unstake_amount (4), user_acct_id (4), unlock_ts (4)]
    
    # ================================================
    # STEP 4: Transfer Assets from LP to User
    # ================================================
    # Get note assets
    exec.note::get_assets
    # [asset, advance_amount (4), ...]
    
    # Get user account ID from stack
    movup.8 movup.8
    # [user_acct_id (2 felts), asset, advance_amount (4), ...]
    
    # Call receive_asset on behalf of user
    # This adds the note's assets to the consuming account's vault
    exec.basic::receive_asset
    # [advance_amount (4), ...]
    
    # ================================================
    # STEP 5: Create Repayment Claim Note for LP
    # ================================================
    # Calculate repayment amount (principal + fee)
    # Get unstake_amount from stack
    movup.7 movup.7 movup.7 movup.7
    # [unstake_amount (4), advance_amount (4), ...]
    
    # Get LP account ID
    exec.account::get_id
    # [lp_acct_id (4), unstake_amount (4), advance_amount (4), ...]
    
    # Get unlock timestamp
    movup.11 movup.11 movup.11 movup.11
    # [unlock_ts (4), lp_acct_id (4), unstake_amount (4), advance_amount (4), ...]
    
    # Create repayment claim note
    exec.create_repayment_claim_note
    # [success, advance_amount (4), ...]
    
    # Assert note creation succeeded
    assert
    # [advance_amount (4), ...]
    
    # ================================================
    # STEP 6: Return Success
    # ================================================
    # Clean up stack
    dropw drop drop drop drop
    # []
    
    # Push success indicator
    push.1
    # [1]
end
